# GitHub 이슈 해결 계획 수립

당신은 GitHub 이슈를 분석하고 체계적인 해결 계획을 수립하는 전문가입니다.

## 🎯 이슈 번호

```text
$ARGUMENT
```

---

## 📋 프로세스 개요

1. GitHub에서 이슈 정보 가져오기
2. 이슈 분석 및 요구사항 파악
3. 해결 계획 수립 (Phase별 분해)
4. 사용자에게 계획 검토 요청
5. 승인 후 실행 시작

---

## Step 1: GitHub 이슈 가져오기

### 1.1 이슈 정보 조회

`gh issue view` 명령어로 이슈의 전체 내용을 가져오세요:

```bash
gh issue view $ARGUMENT --json number,title,body,labels,state,assignees,milestone,author,createdAt,updatedAt,comments
```

**출력 정보**:
- `number`: 이슈 번호
- `title`: 이슈 제목
- `body`: 이슈 본문
- `labels`: 라벨 목록
- `state`: 상태 (OPEN, CLOSED)
- `assignees`: 할당된 사람
- `comments`: 댓글 (추가 컨텍스트 확인)

### 1.2 관련 파일 및 코드 탐색

이슈 본문에서 언급된 파일 경로, 컴포넌트, 함수 등을 파악하고:
- Glob으로 관련 파일 찾기
- Grep으로 관련 코드 검색
- Read로 핵심 파일 읽기

---

## Step 2: 이슈 분석

### 2.1 이슈 유형 파악

라벨과 내용을 기반으로 이슈 유형을 분류하세요:

- **🐛 Bug (버그 수정)**
  - 재현 단계 확인
  - 기대 동작 vs 실제 동작 파악
  - 에러 메시지/로그 분석

- **✨ Feature (기능 구현)**
  - 요구사항 명세 확인
  - UI/UX 목업 확인
  - 데이터 구조 변경 필요성 파악

- **🔧 Refactoring (리팩토링)**
  - 개선 목표 파악
  - 영향 범위 분석
  - 기존 기능 유지 확인

- **📚 Documentation (문서화)**
  - 문서화 대상 파악
  - 대상 독자 확인

- **⚡ Performance (성능 개선)**
  - 성능 병목 지점 파악
  - 측정 기준 확인

### 2.2 요구사항 명확화

다음 질문에 답하세요:

1. **무엇을 달성해야 하는가?**
   - 이슈의 핵심 목표
   - 성공 기준 (Definition of Done)

2. **왜 이 작업이 필요한가?**
   - 비즈니스 가치
   - 사용자 영향도

3. **어디에 영향을 미치는가?**
   - 수정/추가할 파일 목록
   - 의존성 있는 컴포넌트
   - 데이터 모델 변경 여부

4. **어떻게 검증할 것인가?**
   - 테스트 방법
   - 수동 검증 단계
   - 회귀 테스트 필요성

### 2.3 제약 조건 및 리스크 식별

- **기술적 제약**:
  - 현재 기술 스택 (Next.js 15, TypeScript 등)
  - 기존 아키텍처 (Server/Client Components)
  - 디자인 시스템 (Skeuomorphic)

- **비기능적 요구사항**:
  - 성능 목표
  - 접근성 (a11y)
  - 반응형 디자인

- **리스크**:
  - 기존 기능 영향도
  - 복잡도 (예상 작업 시간)
  - 불확실성 (모호한 요구사항)

---

## Step 3: 해결 계획 수립

### 3.1 Phase별 분해

이슈를 **3-5개의 Phase**로 나누세요. 각 Phase는:
- 독립적으로 검증 가능
- 명확한 완료 기준
- 의존성 순서 고려

#### Phase 템플릿

**버그 수정의 경우**:
- Phase 1: 문제 재현 및 원인 파악
- Phase 2: 수정 구현
- Phase 3: 테스트 및 회귀 방지
- Phase 4: 문서화 및 정리

**기능 구현의 경우**:
- Phase 1: 데이터 구조 및 타입 정의
- Phase 2: 핵심 로직 구현
- Phase 3: UI 컴포넌트 구현
- Phase 4: 통합 및 테스트
- Phase 5: 문서화 및 정리

**리팩토링의 경우**:
- Phase 1: 현재 코드 분석 및 테스트 커버리지 확인
- Phase 2: 리팩토링 실행
- Phase 3: 테스트 검증
- Phase 4: 문서 업데이트

### 3.2 작업 세분화

각 Phase를 **5-10개의 구체적인 작업**으로 분해하세요.

#### 작업 작성 규칙

✅ **좋은 작업**:
- 동사로 시작 (추가, 수정, 생성, 제거 등)
- 구체적인 대상 명시 (파일명, 함수명, 컴포넌트명)
- 30분 이내 완료 가능
- 명확한 완료 기준

❌ **나쁜 작업**:
- 모호한 표현
- 여러 작업이 섞임
- 너무 큰 범위

#### 각 작업의 구조

```markdown
- [ ] [구체적인 작업명]
  - 파일: [수정할 파일 경로]
  - 목표: [이 작업의 목표]
  - 예상 시간: [5분/15분/30분]
  - 검증: [완료 확인 방법]
```

### 3.3 우선순위 및 의존성

- **🔴 Critical**: 반드시 먼저 수행 (타입 정의, 기본 구조)
- **🟡 High**: 핵심 기능 구현
- **🟢 Normal**: 부가 기능, 개선사항

**의존성 표시**:
- A → B → C (순차적)
- A, B (병렬 가능)

---

## Step 4: 계획 검토 및 사용자 승인

### 4.1 계획 요약 작성

다음 형식으로 계획을 요약하세요:

```markdown
# 이슈 #$ARGUMENT 해결 계획

## 📌 이슈 요약
- **제목**: [이슈 제목]
- **유형**: [Bug/Feature/Refactoring/Documentation/Performance]
- **우선순위**: [Critical/High/Medium/Low]

## 🎯 목표
[이슈를 통해 달성하려는 목표]

## 📋 해결 계획

### Phase 1: [Phase 이름]
**목표**: [Phase 목표]
**예상 시간**: [30분/1시간/2시간]
**작업 목록**:
- [ ] 작업 1
- [ ] 작업 2
- [ ] ...

### Phase 2: [Phase 이름]
...

## 🔍 검증 방법
- [ ] [검증 항목 1]
- [ ] [검증 항목 2]
- [ ] [검증 항목 3]

## ⚠️ 주의사항 및 리스크
- [주의사항 1]
- [주의사항 2]

## 📁 영향받는 파일
- `[파일 경로 1]`
- `[파일 경로 2]`

## ⏱️ 예상 소요 시간
**총 예상 시간**: [X시간]
```

### 4.2 사용자에게 제시

계획을 사용자에게 명확하게 제시하고 다음을 안내하세요:

```markdown
## 🤔 계획 검토 요청

위 계획을 검토해주세요. 다음 옵션 중 선택해주세요:

1. **✅ 승인 및 시작**: 계획대로 작업을 시작합니다
2. **✏️ 수정 요청**: 특정 부분을 수정하고 싶으시면 말씀해주세요
3. **❓ 질문**: 계획에 대해 질문이 있으시면 말씀해주세요
4. **🔄 다른 접근**: 다른 해결 방법을 원하시면 제안해주세요

**응답 예시**:
- "좋아, 시작해"
- "Phase 2를 더 세분화해줘"
- "리팩토링 대신 새로운 컴포넌트를 만드는 건 어때?"
```

### 4.3 대기 상태

**IMPORTANT**: 계획을 제시한 후에는 **반드시 사용자의 승인을 기다리세요**.
- TodoWrite는 아직 사용하지 마세요 (사용자 승인 후 사용)
- 작업을 시작하지 마세요
- 사용자의 피드백을 기다리세요

---

## Step 5: 승인 후 실행

사용자가 승인하면:

### 5.1 TodoWrite로 작업 목록 생성

```typescript
TodoWrite({
  todos: [
    {
      content: "Phase 1: [Phase 이름]",
      status: "pending",
      activeForm: "Phase 1 작업 중"
    },
    {
      content: "[작업 1]",
      status: "pending",
      activeForm: "[작업 1] 수행 중"
    },
    // ... 모든 작업
  ]
})
```

### 5.2 첫 번째 작업 시작

- 첫 번째 작업을 `in_progress`로 변경
- 즉시 작업 시작
- 완료 시마다 `completed`로 업데이트

### 5.3 진행 중 보고

각 Phase 완료 시:
- 완료된 내용 요약
- 다음 Phase 시작 안내
- 이슈 발생 시 즉시 보고

---

## 💡 분석 가이드라인

### 버그 이슈 분석 시

1. **재현 단계 검증**
   - 이슈에 명시된 재현 단계 확인
   - 직접 재현 가능한지 파악
   - 재현 안 되면 추가 정보 요청 고려

2. **원인 추적 전략**
   - 에러 메시지에서 파일 경로 추출
   - 관련 코드 읽고 로직 파악
   - 가설 수립 및 검증 계획

3. **영향 범위 분석**
   - 버그가 영향을 미치는 기능 파악
   - 회귀 테스트 필요성 판단

### 기능 이슈 분석 시

1. **요구사항 구체화**
   - 이슈 본문에서 명확한 요구사항 추출
   - 모호한 부분은 가정을 명시하고 사용자 확인 요청
   - Acceptance Criteria 정의

2. **기술적 설계**
   - 데이터 모델 변경 필요성
   - 새 컴포넌트 vs 기존 컴포넌트 수정
   - API 연동 필요성 (현재는 mock 데이터)

3. **UI/UX 고려사항**
   - Skeuomorphic 디자인 시스템 준수
   - 반응형 디자인 (모바일/태블릿/데스크톱)
   - 접근성 (a11y)

### 리팩토링 이슈 분석 시

1. **현재 문제점 파악**
   - 코드 중복
   - 복잡도 (순환 복잡도)
   - 유지보수성

2. **개선 목표 설정**
   - 성능 개선
   - 가독성 향상
   - 테스트 용이성

3. **안전성 확보**
   - 기존 기능 변경 없음 확인
   - 테스트 커버리지 확인
   - 단계적 리팩토링 계획

---

## 🔍 검증 체크리스트

계획 수립 후 다음을 확인하세요:

### 계획 품질 체크
- [ ] 모든 Phase가 명확한 목표를 가지는가?
- [ ] 각 작업이 30분 이내로 완료 가능한가?
- [ ] 의존성 순서가 올바른가?
- [ ] 검증 방법이 구체적인가?

### 완성도 체크
- [ ] 이슈의 모든 요구사항이 계획에 포함되었는가?
- [ ] 엣지 케이스 처리가 고려되었는가?
- [ ] 문서화 작업이 포함되었는가?
- [ ] 테스트 작업이 포함되었는가?

### 리스크 체크
- [ ] 예상되는 문제점이 식별되었는가?
- [ ] 기존 기능 영향도가 평가되었는가?
- [ ] 불확실한 부분이 명시되었는가?

---

## 📝 예시

### 입력 예시 1: 버그 이슈
```bash
/solve-issue 42
```

### 예상 출력
```markdown
# 이슈 #42 해결 계획

## 📌 이슈 요약
- **제목**: Fix: 도시 상세페이지에서 좋아요 버튼 클릭 시 카운트가 업데이트되지 않음
- **유형**: Bug
- **우선순위**: High

## 🎯 목표
좋아요 버튼 클릭 시 즉시 UI에 반영되고 상태가 올바르게 관리되도록 수정

## 📋 해결 계획

### Phase 1: 문제 재현 및 원인 파악 (15분)
- [ ] 개발 서버 실행 및 버그 재현
- [ ] LikeDislikeButton 컴포넌트 코드 분석
- [ ] 상태 관리 로직 확인 (useState)
- [ ] 콘솔 로그로 이벤트 핸들러 동작 확인

### Phase 2: 수정 구현 (20분)
- [ ] LikeDislikeButton의 상태 업데이트 로직 수정
- [ ] 낙관적 업데이트 (Optimistic Update) 구현
- [ ] 에러 처리 추가

### Phase 3: 테스트 및 검증 (15분)
- [ ] 좋아요/싫어요 버튼 클릭 테스트
- [ ] 여러 번 클릭 테스트
- [ ] 다른 도시 카드에서도 동작 확인

### Phase 4: 정리 (10분)
- [ ] 디버그 코드 제거
- [ ] TypeScript 타입 체크
- [ ] ESLint 검사

## 🔍 검증 방법
- [ ] 좋아요 버튼 클릭 시 카운트가 즉시 증가
- [ ] 싫어요 버튼 클릭 시 카운트가 즉시 증가
- [ ] 새로고침 후에도 카운트 유지 (현재는 mock이므로 로컬 스토리지 고려)
- [ ] 콘솔 에러 없음

## ⚠️ 주의사항 및 리스크
- 현재는 mock 데이터이므로 실제 API 연동 시 추가 작업 필요
- 로컬 스토리지를 사용하면 브라우저별 데이터 격리

## 📁 영향받는 파일
- `components/like-dislike-button.tsx`
- 필요시 `lib/mock-data.ts`

## ⏱️ 예상 소요 시간
**총 예상 시간**: 1시간

---

## 🤔 계획 검토 요청

위 계획을 검토해주세요. 승인하시면 "좋아, 시작해" 라고 말씀해주세요.
```

---

## 🎬 실행 순서 요약

1. ✅ `gh issue view $ARGUMENT` 실행하여 이슈 정보 가져오기
2. ✅ 관련 파일 및 코드 탐색 (Glob, Grep, Read)
3. ✅ 이슈 분석 (유형, 요구사항, 제약사항)
4. ✅ Phase별 계획 수립
5. ✅ 작업 세분화 (각 Phase를 5-10개 작업으로)
6. ✅ 계획 요약 작성 및 사용자에게 제시
7. ⏸️ **사용자 승인 대기** (TodoWrite 사용 안 함, 작업 시작 안 함)
8. ✅ 승인 받으면 TodoWrite로 작업 목록 생성
9. ✅ 첫 번째 작업 시작

---

## ⚠️ 중요 알림

**계획을 제시한 후에는 반드시 사용자의 명시적 승인을 기다리세요.**

다음과 같은 응답이 있을 때만 작업을 시작하세요:
- "좋아", "시작해", "ㄱㄱ", "승인"
- "괜찮아", "OK", "진행해"

다음과 같은 응답이 있으면 계획을 수정하세요:
- "Phase 2를 더 자세히 나눠줘"
- "다른 방법은 없어?"
- "이 부분은 생략하고 싶어"
